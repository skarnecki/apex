// Package java implements the "java" runtime.
package java

import (
	azip "archive/zip"

	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"

	"errors"

	"bytes"
	"text/template"

	"github.com/apex/apex/function"
	"github.com/jpillora/archive"
)

const (
	// Runtime name used by Apex
	Runtime = "java"
	// RuntimeCanonical represents names used by AWS Lambda
	RuntimeCanonical = "java8"
	// targetJarFile mvn target jar file name
	targetJarFile = "apex-plugin-target"
	// resourcePath path to resource files
	resourcePath = "src/main/resources"
	//apexResourceFile name of generated properties file
	apexResourceFile = "apex.properties"
)

// prelude script template.
var properties = template.Must(template.New("properties").Parse(
	`# Properties generated by Apex - do not edit
{{range $index, $element := .Env}}{{$index}}={{$element}}
{{end}}`))

func init() {
	function.RegisterPlugin("java", &Plugin{})
}

// Plugin implementation.
type Plugin struct{}

// Open adds java defaults.
func (p *Plugin) Open(fn *function.Function) error {
	if fn.Runtime != Runtime {
		return nil
	}

	fn.Runtime = RuntimeCanonical

	if fn.Handler == "" {
		fn.Handler = "lambda.Main::handler"
	}

	fn.Hooks.Clean = "mvn clean"

	return nil
}

// Build calls mvn package, add jar contents to zipfile.
func (p *Plugin) Build(fn *function.Function, zip *archive.Archive) error {
	if fn.Runtime != RuntimeCanonical {
		return nil
	}

	if fn.Environment != nil {
		fn.Log.Debug("creating properties file")
		if err := p.generatePropertiesFile(fn); err != nil {
			return errors.New("Can't generate properties file: " + err.Error())
		}
	}

	fn.Log.Debug("creating jar")
	mvnCmd := exec.Command("mvn", "package", "-Djar.finalName="+targetJarFile)
	mvnCmd.Dir = fn.Path
	if err := mvnCmd.Run(); err != nil {
		return err
	}

	expectedJarPath := filepath.Join(fn.Path, "target", targetJarFile+".jar")
	if _, err := os.Stat(expectedJarPath); err != nil {
		return errors.New("Expected jar file not found")
	}

	fn.Log.Debug("appending compiled files")
	reader, err := azip.OpenReader(expectedJarPath)
	if err != nil {
		return err
	}
	defer reader.Close()

	for _, file := range reader.File {
		r, err := file.Open()
		if err != nil {
			return err
		}

		b, err := ioutil.ReadAll(r)
		if err != nil {
			return err
		}
		r.Close()

		zip.AddBytes(file.Name, b)
	}

	if err := p.cleanProperties(fn); err != nil {
		return err
	}

	return nil
}

// cleanProperties removes generated property file and resource dir (if empty)
func (p *Plugin) cleanProperties(fn *function.Function) error {
	expectedProps := filepath.Join(fn.Path, resourcePath, apexResourceFile)
	if _, err := os.Stat(expectedProps); err == nil {
		fn.Log.Debug("removing properties file")
		if err := os.Remove(expectedProps); err != nil {
			return err
		}
	}

	resourceDir := filepath.Join(fn.Path, resourcePath)
	files, err := ioutil.ReadDir(resourceDir)
	if err != nil {
		return err
	}
	if len(files) < 1 {
		os.Remove(resourceDir)
	}

	return nil
}

// generatePropertiesFile generates property file with all environment variables
func (p *Plugin) generatePropertiesFile(fn *function.Function) error {
	var propertiesFile bytes.Buffer
	err := properties.Execute(&propertiesFile, struct {
		Env map[string]string
	}{
		Env: fn.Environment,
	})

	if err != nil {
		return err
	}

	if err := os.MkdirAll(filepath.Join(fn.Path, resourcePath), 0777); err != nil {
		return err
	}

	if err := ioutil.WriteFile(filepath.Join(fn.Path, resourcePath, apexResourceFile), propertiesFile.Bytes(), 0777); err != nil {
		return err
	}
	return nil
}
